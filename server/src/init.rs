use std::path::{Path, PathBuf};

// ---------------------------------------------------------------------------
// Project type detection
// ---------------------------------------------------------------------------

#[derive(Debug, Clone, Copy, PartialEq)]
enum ProjectType {
    Rust,
    Node,
    Go,
    UnrealEngine,
    Python,
    Unknown,
}

impl ProjectType {
    fn label(self) -> &'static str {
        match self {
            Self::Rust => "Rust",
            Self::Node => "Node.js",
            Self::Go => "Go",
            Self::UnrealEngine => "Unreal Engine",
            Self::Python => "Python",
            Self::Unknown => "Unknown",
        }
    }
}

fn detect_project_type(root: &Path) -> ProjectType {
    if root.join("Cargo.toml").exists() {
        return ProjectType::Rust;
    }
    if root.join("package.json").exists() {
        return ProjectType::Node;
    }
    if root.join("go.mod").exists() {
        return ProjectType::Go;
    }
    if root.join("pyproject.toml").exists() || root.join("setup.py").exists() {
        return ProjectType::Python;
    }
    // Check for *.uproject
    if let Ok(entries) = std::fs::read_dir(root) {
        for entry in entries.flatten() {
            if let Some(ext) = entry.path().extension() {
                if ext == "uproject" {
                    return ProjectType::UnrealEngine;
                }
            }
        }
    }
    ProjectType::Unknown
}

// ---------------------------------------------------------------------------
// .codescope.toml generation
// ---------------------------------------------------------------------------

fn generate_codescope_toml(project_type: ProjectType) -> Option<String> {
    let (scan_dirs, extensions): (Vec<&str>, Vec<&str>) = match project_type {
        ProjectType::Rust => (
            vec!["src", "crates"],
            vec!["rs", "toml"],
        ),
        ProjectType::Node => (
            vec!["src", "lib", "app"],
            vec!["ts", "tsx", "js", "jsx", "json"],
        ),
        ProjectType::Go => (
            vec![],
            vec!["go", "mod"],
        ),
        ProjectType::UnrealEngine => (
            vec!["Source"],
            vec!["h", "cpp", "cs", "usf", "ush"],
        ),
        ProjectType::Python => (
            vec!["src"],
            vec!["py", "pyi"],
        ),
        ProjectType::Unknown => return None,
    };

    let mut out = String::new();
    out.push_str("# Generated by codescope-server init\n");
    out.push_str(&format!("# Project type: {}\n\n", project_type.label()));

    if !scan_dirs.is_empty() {
        let quoted: Vec<String> = scan_dirs.iter().map(|d| format!("\"{}\"", d)).collect();
        out.push_str(&format!("scan_dirs = [{}]\n", quoted.join(", ")));
    }

    if !extensions.is_empty() {
        let quoted: Vec<String> = extensions.iter().map(|e| format!("\"{}\"", e)).collect();
        out.push_str(&format!("extensions = [{}]\n", quoted.join(", ")));
    }

    Some(out)
}

// ---------------------------------------------------------------------------
// .mcp.json generation / merge
// ---------------------------------------------------------------------------

fn codescope_mcp_entry(root: &Path) -> serde_json::Value {
    serde_json::json!({
        "type": "stdio",
        "command": "codescope-server",
        "args": ["--mcp", "--root", root.to_string_lossy()]
    })
}

fn write_or_merge_mcp_json(root: &Path) -> Result<(), String> {
    let mcp_path = root.join(".mcp.json");
    let entry = codescope_mcp_entry(root);

    if mcp_path.exists() {
        let content = std::fs::read_to_string(&mcp_path)
            .map_err(|e| format!("Failed to read {}: {}", mcp_path.display(), e))?;
        let mut data: serde_json::Value = serde_json::from_str(&content)
            .map_err(|e| format!("Failed to parse {}: {}", mcp_path.display(), e))?;

        // Check if codescope already exists
        if let Some(servers) = data.get("mcpServers").and_then(|v| v.as_object()) {
            if servers.contains_key("codescope") {
                eprintln!("  codescope already configured in .mcp.json");
                return Ok(());
            }
        }

        // Merge
        let servers = data
            .as_object_mut()
            .ok_or("Invalid .mcp.json: not an object")?
            .entry("mcpServers")
            .or_insert_with(|| serde_json::json!({}));
        servers
            .as_object_mut()
            .ok_or("Invalid .mcp.json: mcpServers is not an object")?
            .insert("codescope".to_string(), entry);

        let output = serde_json::to_string_pretty(&data)
            .map_err(|e| format!("Failed to serialize .mcp.json: {}", e))?;
        std::fs::write(&mcp_path, format!("{}\n", output))
            .map_err(|e| format!("Failed to write {}: {}", mcp_path.display(), e))?;
        eprintln!("  Added codescope to existing .mcp.json");
    } else {
        let data = serde_json::json!({
            "mcpServers": {
                "codescope": entry
            }
        });
        let output = serde_json::to_string_pretty(&data)
            .map_err(|e| format!("Failed to serialize .mcp.json: {}", e))?;
        std::fs::write(&mcp_path, format!("{}\n", output))
            .map_err(|e| format!("Failed to write {}: {}", mcp_path.display(), e))?;
        eprintln!("  Created .mcp.json");
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Global repos.toml merge
// ---------------------------------------------------------------------------

fn merge_global_repos_toml(root: &Path) -> Result<(), String> {
    let home = std::env::var("HOME").map_err(|_| "HOME not set".to_string())?;
    let dir = PathBuf::from(&home).join(".codescope");
    let toml_path = dir.join("repos.toml");

    let repo_name = root
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("default");

    // Read existing or start fresh
    let mut table: toml::Table = if toml_path.exists() {
        let content = std::fs::read_to_string(&toml_path)
            .map_err(|e| format!("Failed to read {}: {}", toml_path.display(), e))?;
        content
            .parse()
            .map_err(|e| format!("Failed to parse {}: {}", toml_path.display(), e))?
    } else {
        toml::Table::new()
    };

    let repos = table
        .entry("repos")
        .or_insert_with(|| toml::Value::Table(toml::Table::new()));
    let repos = repos
        .as_table_mut()
        .ok_or("repos is not a table in repos.toml")?;

    if repos.contains_key(repo_name) {
        eprintln!(
            "  Repo '{}' already in {}",
            repo_name,
            toml_path.display()
        );
        return Ok(());
    }

    let mut entry = toml::Table::new();
    entry.insert(
        "root".to_string(),
        toml::Value::String(root.to_string_lossy().to_string()),
    );
    repos.insert(repo_name.to_string(), toml::Value::Table(entry));

    std::fs::create_dir_all(&dir)
        .map_err(|e| format!("Failed to create {}: {}", dir.display(), e))?;
    let output = toml::to_string_pretty(&table)
        .map_err(|e| format!("Failed to serialize repos.toml: {}", e))?;
    std::fs::write(&toml_path, output)
        .map_err(|e| format!("Failed to write {}: {}", toml_path.display(), e))?;

    eprintln!(
        "  Added '{}' to {}",
        repo_name,
        toml_path.display()
    );
    Ok(())
}

// ---------------------------------------------------------------------------
// codescope-server init
// ---------------------------------------------------------------------------

pub fn run_init(args: &[String]) -> i32 {
    let global = args.iter().any(|a| a == "--global");

    // Find the path argument (skip "init", skip flags)
    let path_arg = args
        .iter()
        .skip(1) // skip "init"
        .find(|a| !a.starts_with('-'));

    let root = match path_arg {
        Some(p) => PathBuf::from(p),
        None => std::env::current_dir().unwrap_or_else(|e| {
            eprintln!("Error: Could not determine current directory: {}", e);
            std::process::exit(1);
        }),
    };

    let root = root.canonicalize().unwrap_or_else(|e| {
        eprintln!("Error: Path '{}' not found: {}", root.display(), e);
        std::process::exit(1);
    });

    let version = env!("CARGO_PKG_VERSION");
    eprintln!("codescope-server {} init", version);
    eprintln!("  Project root: {}", root.display());

    let project_type = detect_project_type(&root);
    eprintln!("  Detected: {} project", project_type.label());

    // Generate .codescope.toml
    if let Some(toml_content) = generate_codescope_toml(project_type) {
        let config_path = root.join(".codescope.toml");
        if config_path.exists() {
            eprintln!("  .codescope.toml already exists, skipping");
        } else {
            if let Err(e) = std::fs::write(&config_path, &toml_content) {
                eprintln!("Error: Failed to write .codescope.toml: {}", e);
                return 1;
            }
            eprintln!("  Created .codescope.toml");
        }
    } else {
        eprintln!("  Unknown project type, skipping .codescope.toml");
    }

    // Generate or merge .mcp.json
    if let Err(e) = write_or_merge_mcp_json(&root) {
        eprintln!("Error: {}", e);
        return 1;
    }

    // Global repos.toml
    if global {
        if let Err(e) = merge_global_repos_toml(&root) {
            eprintln!("Error: {}", e);
            return 1;
        }
    }

    eprintln!();
    eprintln!(
        "  Open Claude Code in {} -- CodeScope tools are now available.",
        root.display()
    );
    0
}

// ---------------------------------------------------------------------------
// codescope-server doctor
// ---------------------------------------------------------------------------

pub fn run_doctor(args: &[String]) -> i32 {
    // Find the path argument (skip "doctor", skip flags)
    let path_arg = args
        .iter()
        .skip(1) // skip "doctor"
        .find(|a| !a.starts_with('-'));

    let root = match path_arg {
        Some(p) => PathBuf::from(p),
        None => std::env::current_dir().unwrap_or_else(|e| {
            eprintln!("Error: Could not determine current directory: {}", e);
            std::process::exit(1);
        }),
    };

    let root = root.canonicalize().unwrap_or_else(|e| {
        eprintln!("Error: Path '{}' not found: {}", root.display(), e);
        std::process::exit(1);
    });

    let version = env!("CARGO_PKG_VERSION");
    let mut has_warn = false;
    let mut has_fail = false;

    eprintln!("codescope-server doctor");
    eprintln!();

    // 1. Binary version
    eprintln!("  [PASS] codescope-server v{}", version);

    // 2. Check .codescope.toml
    let config_path = root.join(".codescope.toml");
    if config_path.exists() {
        let content = std::fs::read_to_string(&config_path).unwrap_or_default();
        match content.parse::<toml::Table>() {
            Ok(_) => eprintln!("  [PASS] .codescope.toml exists and is valid TOML"),
            Err(e) => {
                eprintln!("  [FAIL] .codescope.toml exists but is invalid: {}", e);
                has_fail = true;
            }
        }
    } else {
        eprintln!("  [WARN] .codescope.toml not found (will use defaults)");
        has_warn = true;
    }

    // 3. Check .mcp.json
    let mcp_path = root.join(".mcp.json");
    if mcp_path.exists() {
        let content = std::fs::read_to_string(&mcp_path).unwrap_or_default();
        match serde_json::from_str::<serde_json::Value>(&content) {
            Ok(data) => {
                if data
                    .get("mcpServers")
                    .and_then(|v| v.get("codescope"))
                    .is_some()
                {
                    eprintln!("  [PASS] .mcp.json has codescope entry");
                } else {
                    eprintln!("  [WARN] .mcp.json exists but missing codescope entry");
                    has_warn = true;
                }
            }
            Err(e) => {
                eprintln!("  [FAIL] .mcp.json exists but is invalid JSON: {}", e);
                has_fail = true;
            }
        }
    } else {
        eprintln!("  [FAIL] .mcp.json not found (run: codescope-server init)");
        has_fail = true;
    }

    // 4. Quick test scan (limit 100 files)
    let config = crate::load_codescope_config(&root);

    let scan_dirs: Vec<String> = if config.scan_dirs.is_empty() {
        vec![".".to_string()]
    } else {
        config.scan_dirs.clone()
    };

    let start = std::time::Instant::now();
    let mut file_count: usize = 0;
    let mut estimated_total: usize = 0;
    let scan_limit = 100;

    for dir_name in &scan_dirs {
        let scan_root = if dir_name == "." {
            root.clone()
        } else {
            root.join(dir_name)
        };
        if !scan_root.exists() {
            continue;
        }

        let walker = ignore::WalkBuilder::new(&scan_root)
            .hidden(true)
            .git_ignore(true)
            .build();

        for entry in walker.flatten() {
            if !entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
                continue;
            }

            let path = entry.path();

            // Apply skip_dirs
            let mut skip = false;
            for component in path.components() {
                if let std::path::Component::Normal(name) = component {
                    if let Some(name_str) = name.to_str() {
                        if config.skip_dirs.contains(name_str) {
                            skip = true;
                            break;
                        }
                    }
                }
            }
            if skip {
                continue;
            }

            // Apply extension filter
            if !config.extensions.is_empty() {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    if !config.extensions.contains(ext) {
                        continue;
                    }
                } else {
                    continue;
                }
            }

            estimated_total += 1;
            if file_count < scan_limit {
                file_count += 1;
            }
        }
    }
    let elapsed = start.elapsed();

    if file_count > 0 {
        eprintln!(
            "  [PASS] Test scan: found {} files in {:.0?}",
            file_count, elapsed
        );
    } else {
        eprintln!("  [WARN] Test scan: no files found");
        has_warn = true;
    }

    // 5. Total estimated file count
    eprintln!("  [INFO] Estimated total files: {}", estimated_total);

    // 6. Check for nested .git dirs (too-broad root)
    let mut git_dirs = 0;
    if let Ok(entries) = std::fs::read_dir(&root) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() && path.join(".git").exists() {
                git_dirs += 1;
            }
        }
    }
    if git_dirs > 1 {
        eprintln!(
            "  [WARN] Found {} subdirectories with .git -- root may be too broad",
            git_dirs
        );
        has_warn = true;
    }

    // Summary
    eprintln!();
    if has_fail {
        eprintln!("  Result: FAIL -- fix the issues above");
        1
    } else if has_warn {
        eprintln!("  Result: PASS with warnings");
        0
    } else {
        eprintln!("  Result: ALL PASS");
        0
    }
}
